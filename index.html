<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Token Sentiment Dashboard</title>
    <script src="https://unpkg.com/chart.js@4.4.4/dist/chart.umd.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        select {
            padding: 10px;
            font-size: 16px;
            margin-bottom: 20px;
            width: 100%;
            max-width: 300px;
        }
        .chart-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .chart {
            flex: 1 1 300px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .chart canvas {
            max-height: 300px;
        }
        .error, .loading {
            margin-top: 10px;
            font-weight: bold;
        }
        .error { color: red; }
        .loading { color: #555; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Crypto Token Sentiment Dashboard</h1>
        <div class="loading" id="loading-message">Loading tokens...</div>
        <select id="symbol-select">
            <option value="">Select a token</option>
        </select>
        <div id="error-message" class="error"></div>
        <div class="chart-container">
            <div class="chart">
                <h3>Sentiment Score</h3>
                <canvas id="sentimentScoreChart"></canvas>
            </div>
            <div class="chart">
                <h3>Funding Rate (%)</h3>
                <canvas id="fundingRateChart"></canvas>
            </div>
            <div class="chart">
                <h3>Open Interest (USD)</h3>
                <canvas id="openInterestChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing dashboard...');
            const symbolSelect = document.getElementById('symbol-select');
            const errorMessage = document.getElementById('error-message');
            const loadingMessage = document.getElementById('loading-message');
            const COINGECKO_API = 'https://api.coingecko.com/api/v3';
            const MAX_DATA_POINTS = 20;

            // Fallback symbols if CoinGecko fails
            const fallbackSymbols = [
                { symbol: 'BTCUSDT', name: 'Bitcoin (BTC)', geckoId: 'bitcoin' },
                { symbol: 'ETHUSDT', name: 'Ethereum (ETH)', geckoId: 'ethereum' },
                { symbol: 'BNBUSDT', name: 'Binance Coin (BNB)', geckoId: 'binancecoin' },
                { symbol: 'ADAUSDT', name: 'Cardano (ADA)', geckoId: 'cardano' },
                { symbol: 'XRPUSDT', name: 'XRP (XRP)', geckoId: 'ripple' }
            ];

            let chartInstances = {};
            let dataState = {};
            let activeInterval = null;

            const chartConfigs = {
                sentimentScoreChart: {
                    type: 'line',
                    label: 'Sentiment Score',
                    borderColor: '#2ECC71',
                    backgroundColor: 'rgba(46, 204, 113, 0.1)',
                    options: { scales: { y: { min: -10, max: 10 } } }
                },
                fundingRateChart: {
                    type: 'bar',
                    label: 'Funding Rate (Proxy)',
                    backgroundColor: '#3498DB'
                },
                openInterestChart: {
                    type: 'line',
                    label: 'Open Interest (Proxy - 24h Vol)',
                    borderColor: '#F39C12'
                }
            };

            async function fetchTop100Tokens() {
                try {
                    console.log('Fetching tokens from CoinGecko...');
                    loadingMessage.textContent = 'Loading token list...';
                    const response = await fetch(`${COINGECKO_API}/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=100&page=1&sparkline=false`);
                    if (!response.ok) throw new Error(`CoinGecko API error: ${response.status}`);
                    const tokens = await response.json();
                    
                    symbolSelect.innerHTML = '<option value="">Select a token</option>'; // Clear previous
                    
                    tokens.forEach(token => {
                        const symbol = token.symbol.toUpperCase() + 'USDT';
                        const option = document.createElement('option');
                        option.value = symbol;
                        option.dataset.geckoId = token.id;
                        option.textContent = `${token.name} (${token.symbol.toUpperCase()})`;
                        symbolSelect.appendChild(option);
                    });

                    loadingMessage.style.display = 'none';
                    if (tokens.length > 0) {
                        symbolSelect.value = 'BTCUSDT';
                        changeSymbol(symbolSelect.value);
                    }
                } catch (error) {
                    console.error('CoinGecko fetch failed:', error);
                    errorMessage.textContent = 'Failed to load tokens from CoinGecko. Using fallback list.';
                    fallbackSymbols.forEach(token => {
                        const option = document.createElement('option');
                        option.value = token.symbol;
                        option.dataset.geckoId = token.geckoId;
                        option.textContent = token.name;
                        symbolSelect.appendChild(option);
                    });
                    symbolSelect.value = 'BTCUSDT';
                    changeSymbol(symbolSelect.value);
                } finally {
                    loadingMessage.style.display = 'none';
                }
            }

            function createOrUpdateChart(canvasId, config, labels, data) {
                if (chartInstances[canvasId]) {
                    chartInstances[canvasId].destroy();
                }
                const ctx = document.getElementById(canvasId)?.getContext('2d');
                if (!ctx) return;
                chartInstances[canvasId] = new Chart(ctx, {
                    type: config.type,
                    data: {
                        labels: labels,
                        datasets: [{ ...config, data: data }]
                    },
                    options: { responsive: true, ...config.options }
                });
            }

            function addDataToCharts(symbol, newData) {
                const now = new Date().toLocaleTimeString();
                const state = dataState[symbol];

                state.labels.push(now);
                state.sentimentData.push(newData.sentimentScore);
                state.fundingData.push(newData.fundingRate * 100);
                state.oiData.push(newData.openInterest);

                if (state.labels.length > MAX_DATA_POINTS) {
                    ['labels', 'sentimentData', 'fundingData', 'oiData'].forEach(key => state[key].shift());
                }

                if (symbolSelect.value === symbol) {
                    updateAllCharts(symbol);
                }
            }

            function updateAllCharts(symbol) {
                const state = dataState[symbol];
                createOrUpdateChart('sentimentScoreChart', chartConfigs.sentimentScoreChart, state.labels, state.sentimentData);
                createOrUpdateChart('fundingRateChart', chartConfigs.fundingRateChart, state.labels, state.fundingData);
                createOrUpdateChart('openInterestChart', chartConfigs.openInterestChart, state.labels, state.oiData);
            }

            async function fetchSentimentScore() {
                const res = await fetch('https://api.alternative.me/fng/');
                const json = await res.json();
                const value = parseInt(json.data[0].value);
                return ((value - 50) / 50) * 10;
            }

            async function fetchCoinGeckoMetrics(symbolId) {
                const url = `${COINGECKO_API}/coins/${symbolId}?localization=false&tickers=false&market_data=true&sparkline=false`;
                const res = await fetch(url);
                if (!res.ok) throw new Error(`CoinGecko data fetch failed: ${res.status}`);
                const data = await res.json();
                const market = data.market_data;
                return {
                    fundingRate: (market.price_change_percentage_24h_in_currency.usd || 0) / 1000,
                    openInterest: market.total_volume.usd || 0,
                    price: market.current_price.usd
                };
            }

            async function fetchData(symbol) {
                try {
                    console.log(`Fetching data for ${symbol}...`);
                    errorMessage.textContent = '';
                    loadingMessage.textContent = `Fetching data for ${symbol}...`;
                    
                    const selectedOption = symbolSelect.querySelector(`option[value="${symbol}"]`);
                    const geckoId = selectedOption?.dataset.geckoId;

                    if (!geckoId) throw new Error('Symbol not supported');

                    const [sentimentScore, marketData] = await Promise.all([
                        fetchSentimentScore(),
                        fetchCoinGeckoMetrics(geckoId)
                    ]);

                    const { fundingRate, openInterest, price } = marketData;
                    const state = dataState[symbol];

                    state.lastOpenInterest = openInterest;
                    state.lastPrice = price;

                    addDataToCharts(symbol, { sentimentScore, fundingRate, openInterest });
                } catch (error) {
                    console.error(`Data fetch failed for ${symbol}:`, error);
                    errorMessage.textContent = `Failed to fetch data for ${symbol}. Please try another token.`;
                } finally {
                    loadingMessage.style.display = 'none';
                }
            }

            function initializeSymbol(symbol) {
                if (!dataState[symbol]) {
                    dataState[symbol] = {
                        labels: [], sentimentData: [], fundingData: [], oiData: [],
                        lastOpenInterest: 0, lastPrice: 0
                    };
                }
            }

            function changeSymbol(symbol) {
                if (!symbol) return;
                console.log(`Switching to symbol: ${symbol}`);
                initializeSymbol(symbol);
                updateAllCharts(symbol);
                if (activeInterval) clearInterval(activeInterval);
                fetchData(symbol);
                activeInterval = setInterval(() => fetchData(symbol), 60000); // Increased interval to 60s
            }

            symbolSelect.addEventListener('change', (event) => {
                changeSymbol(event.target.value);
            });

            fetchTop100Tokens();
        });
    </script>
</body>
</html>