<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Sentiment Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        select {
            padding: 10px;
            font-size: 16px;
            margin-bottom: 20px;
            width: 100%;
            max-width: 300px;
        }
        .chart-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .chart {
            flex: 1 1 300px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .chart canvas {
            max-height: 300px;
        }
        .error, .loading {
            margin-top: 10px;
            font-weight: bold;
        }
        .error { color: red; }
        .loading { color: #555; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Crypto Token Sentiment Dashboard</h1>
        <div class="loading" id="loading-message">Loading tokens...</div>
        <select id="symbol-select">
            <option value="">Select a token</option>
        </select>
        <div id="error-message" class="error"></div>
        <div class="chart-container">
            <div class="chart">
                <h3>Sentiment Score</h3>
                <canvas id="sentimentScoreChart"></canvas>
            </div>
            <div class="chart">
                <h3>Funding Rate (%)</h3>
                <canvas id="fundingRateChart"></canvas>
            </div>
            <div class="chart">
                <h3>Open Interest (USD)</h3>
                <canvas id="openInterestChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing dashboard...');
            const symbolSelect = document.getElementById('symbol-select');
            const errorMessage = document.getElementById('error-message');
            const loadingMessage = document.getElementById('loading-message');
            const API_BASE = 'https://corsproxy.io/?https://fapi.binance.com/fapi/v1';
            const COINGECKO_API = 'https://api.coingecko.com/api/v3';
            const MAX_DATA_POINTS = 20;

            // Fallback symbols (known to have Binance Futures)
            const fallbackSymbols = [
                { symbol: 'BTCUSDT', name: 'Bitcoin (BTC)' },
                { symbol: 'ETHUSDT', name: 'Ethereum (ETH)' },
                { symbol: 'BNBUSDT', name: 'Binance Coin (BNB)' },
                { symbol: 'ADAUSDT', name: 'Cardano (ADA)' },
                { symbol: 'XRPUSDT', name: 'XRP (XRP)' }
            ];

            // Mock data for testing
            const mockData = {
                sentimentScore: 5,
                fundingRate: 0.0005,
                openInterest: 100000000
            };

            let chartInstances = {};
            let dataState = {};
            let activeInterval = null;

            const chartConfigs = {
                sentimentScoreChart: {
                    type: 'line',
                    label: 'Sentiment Score',
                    borderColor: '#2ECC71',
                    backgroundColor: 'rgba(46, 204, 113, 0.1)',
                    options: { scales: { y: { min: -10, max: 10 } } }
                },
                fundingRateChart: {
                    type: 'bar',
                    label: 'Funding Rate (%)',
                    backgroundColor: '#3498DB'
                },
                openInterestChart: {
                    type: 'line',
                    label: 'Open Interest (USD)',
                    borderColor: '#F39C12'
                }
            };

            async function fetchTop100Tokens() {
                try {
                    console.log('Fetching tokens from CoinGecko...');
                    loadingMessage.textContent = 'Loading token list...';
                    const response = await fetch(`${COINGECKO_API}/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=100&page=1&sparkline=false`, {
                        headers: { 'Accept': 'application/json' }
                    });
                    if (!response.ok) throw new Error(`CoinGecko API error: ${response.status}`);
                    const tokens = await response.json();
                    console.log(`Fetched ${tokens.length} tokens`);
                    // Filter for tokens likely on Binance Futures (top 20 by market cap, common symbols)
                    const filteredTokens = tokens
                        .slice(0, 20)
                        .filter(token => ['bitcoin', 'ethereum', 'binancecoin', 'cardano', 'ripple', 'solana', 'dogecoin', 'polkadot', 'matic-network', 'tron'].includes(token.id));
                    filteredTokens.forEach(token => {
                        const symbol = token.symbol.toUpperCase() + 'USDT';
                        const option = document.createElement('option');
                        option.value = symbol;
                        option.textContent = `${token.name} (${token.symbol.toUpperCase()})`;
                        symbolSelect.appendChild(option);
                    });
                    if (filteredTokens.length > 0) {
                        symbolSelect.value = 'BTCUSDT';
                        changeSymbol(symbolSelect.value);
                    } else {
                        throw new Error('No valid tokens found');
                    }
                } catch (error) {
                    console.error('CoinGecko fetch failed:', error);
                    errorMessage.textContent = 'Failed to load tokens from CoinGecko. Using fallback list.';
                    // Use fallback symbols
                    fallbackSymbols.forEach(token => {
                        const option = document.createElement('option');
                        option.value = token.symbol;
                        option.textContent = token.name;
                        symbolSelect.appendChild(option);
                    });
                    symbolSelect.value = 'BTCUSDT';
                    changeSymbol(symbolSelect.value);
                } finally {
                    loadingMessage.style.display = 'none';
                }
            }

            function createOrUpdateChart(canvasId, config, labels, data) {
                try {
                    if (chartInstances[canvasId]) {
                        chartInstances[canvasId].destroy();
                    }
                    const ctx = document.getElementById(canvasId)?.getContext('2d');
                    if (!ctx) throw new Error(`Canvas not found: ${canvasId}`);
                    chartInstances[canvasId] = new Chart(ctx, {
                        type: config.type,
                        data: {
                            labels: labels,
                            datasets: [{
                                label: config.label,
                                data: data,
                                borderColor: config.borderColor,
                                backgroundColor: config.backgroundColor,
                                fill: !!config.backgroundColor,
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            ...config.options
                        }
                    });
                    console.log(`Chart created: ${canvasId}`);
                } catch (error) {
                    console.error(`Chart creation failed for ${canvasId}:`, error);
                    errorMessage.textContent = 'Error rendering charts. Please try another token.';
                }
            }

            function addDataToCharts(symbol, newData) {
                const now = new Date().toLocaleTimeString();
                const state = dataState[symbol];

                state.labels.push(now);
                state.sentimentData.push(newData.sentimentScore);
                state.fundingData.push(newData.fundingRate * 100);
                state.oiData.push(newData.openInterest);

                if (state.labels.length > MAX_DATA_POINTS) {
                    state.labels.shift();
                    state.sentimentData.shift();
                    state.fundingData.shift();
                    state.oiData.shift();
                }

                if (symbolSelect.value === symbol) {
                    updateAllCharts(symbol);
                }
            }

            function updateAllCharts(symbol) {
                const state = dataState[symbol];
                createOrUpdateChart('sentimentScoreChart', chartConfigs.sentimentScoreChart, state.labels, state.sentimentData);
                createOrUpdateChart('fundingRateChart', chartConfigs.fundingRateChart, state.labels, state.fundingData);
                createOrUpdateChart('openInterestChart', chartConfigs.openInterestChart, state.labels, state.oiData);
            }

            function calculateSentimentScore(fundingRate, oi, price, state) {
                let score = 0;
                const fundingRatePercent = fundingRate * 100;
                if (fundingRatePercent > 0.05) score -= 5;
                else if (fundingRatePercent < -0.05) score += 5;
                else score += (fundingRatePercent / 0.05) * -5;

                if (state.lastPrice > 0) {
                    const oiTrend = oi > state.lastOpenInterest;
                    const priceTrend = price > state.lastPrice;
                    if (oiTrend && priceTrend) score += 3;
                    else if (oiTrend && !priceTrend) score -= 3;
                }

                return Math.max(-10, Math.min(10, score));
            }

            async function fetchData(symbol) {
                try {
                    console.log(`Fetching data for ${symbol}...`);
                    errorMessage.textContent = '';
                    loadingMessage.textContent = `Fetching data for ${symbol}...`;
                    const encodedSymbol = encodeURIComponent(symbol);
                    const [premiumIndex, openInterestHist] = await Promise.all([
                        fetch(`${API_BASE}/premiumIndex?symbol=${encodedSymbol}`, {
                            headers: { 'Accept': 'application/json' }
                        }).then(res => {
                            console.log(`PremiumIndex response status: ${res.status}`);
                            return res.json();
                        }),
                        fetch(`${API_BASE}/openInterestHist?symbol=${encodedSymbol}&period=5m&limit=1`, {
                            headers: { 'Accept': 'application/json' }
                        }).then(res => {
                            console.log(`OpenInterestHist response status: ${res.status}`);
                            return res.json();
                        })
                    ]);

                    console.log('PremiumIndex response:', premiumIndex);
                    console.log('OpenInterestHist response:', openInterestHist);

                    if (premiumIndex.code || openInterestHist.code) {
                        throw new Error(`Symbol not found: ${symbol}`);
                    }

                    const fundingRate = parseFloat(premiumIndex.lastFundingRate);
                    const markPrice = parseFloat(premiumIndex.markPrice);
                    const openInterest = parseFloat(openInterestHist[0]?.sumOpenInterestValue);

                    if (isNaN(fundingRate) || isNaN(markPrice) || isNaN(openInterest)) {
                        throw new Error('Invalid data returned from Binance');
                    }

                    const state = dataState[symbol];
                    const sentimentScore = calculateSentimentScore(fundingRate, openInterest, markPrice, state);

                    state.lastOpenInterest = openInterest;
                    state.lastPrice = markPrice;

                    addDataToCharts(symbol, { sentimentScore, fundingRate, openInterest });
                    loadingMessage.style.display = 'none';
                } catch (error) {
                    console.error(`Data fetch failed for ${symbol}:`, error);
                    errorMessage.textContent = `No futures data for ${symbol} on Binance. Using mock data for testing.`;
                    loadingMessage.style.display = 'none';
                    // Use mock data to display something
                    const state = dataState[symbol];
                    addDataToCharts(symbol, {
                        sentimentScore: mockData.sentimentScore,
                        fundingRate: mockData.fundingRate,
                        openInterest: mockData.openInterest
                    });
                }
            }

            function initializeSymbol(symbol) {
                if (!dataState[symbol]) {
                    dataState[symbol] = {
                        labels: [],
                        sentimentData: [],
                        fundingData: [],
                        oiData: [],
                        lastOpenInterest: 0,
                        lastPrice: 0
                    };
                }
            }

            function changeSymbol(symbol) {
                if (!symbol) {
                    errorMessage.textContent = 'Please select a valid token.';
                    return;
                }
                console.log(`Switching to symbol: ${symbol}`);
                initializeSymbol(symbol);
                updateAllCharts(symbol);
                if (activeInterval) clearInterval(activeInterval);
                fetchData(symbol);
                activeInterval = setInterval(() => fetchData(symbol), 30000);
            }

            symbolSelect.addEventListener('change', (event) => {
                changeSymbol(event.target.value);
            });

            // Verify Chart.js loaded
            if (typeof Chart === 'undefined') {
                console.error('Chart.js failed to load');
                errorMessage.textContent = 'Chart.js failed to load. Please check your internet connection.';
                loadingMessage.style.display = 'none';
                return;
            } else {
                console.log('Chart.js loaded successfully');
            }

            // Cache busting for GitHub Pages
            const cacheBuster = `?v=${Date.now()}`;
            console.log('Cache buster:', cacheBuster);

            // Start fetching tokens
            fetchTop100Tokens();
        });
    </script>
</body>
</html>